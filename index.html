<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Smart List</title> <!-- Renamed for broader use -->
    <link rel="shortcut icon" type="image/x-icon" href="logo.ico">

    <meta name="description" content="A smart list app with history, suggestions, and multiple languages.">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f4f7f9; /* Light background */
            --container-bg: #ffffff;
            --container-border: #e0e4e7;
            --text-color: #333333;
            --text-color-muted: #777777;
            --accent-color: #4a90e2; /* Blue accent */
            --accent-color-darker: #357abd;
            --done-color-bg: #e8f5e9; /* Light green background for done items */
            --done-text-color: #555;
            --danger-color: #e94e77;
            --danger-color-darker: #d63060;
            --shadow-color: rgba(0, 0, 0, 0.08);
            --border-radius: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
             height: 100%;
             font-size: 16px; /* Base font size */
        }

        body {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            -webkit-tap-highlight-color: transparent;
        }

        #smart-list-app {
            width: 100%;
            max-width: 750px; /* Slightly wider */
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px var(--shadow-color);
            padding: 25px 30px;
            display: flex;
            flex-direction: column;
            gap: 25px; /* Increased gap */
        }

        h1 {
            text-align: center;
            font-weight: 600;
            color: var(--accent-color);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.8rem;
        }

        /* Form Styling */
        #add-item-form {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            position: relative; /* For suggestions positioning */
        }

        #add-item-form input[type="text"] {
            flex-grow: 1;
            min-width: 180px;
        }

        #item-quantity {
            width: 100px;
        }

        input[type="text"], select {
            background: #fff;
            border: 1px solid var(--container-border);
            color: var(--text-color);
            border-radius: var(--border-radius);
            padding: 12px 15px; /* Increased padding */
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="text"]::placeholder {
            color: var(--text-color-muted);
            opacity: 0.9;
        }
        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2); /* Focus ring */
        }

        /* Buttons */
        button, .button-like {
            background-color: #fff;
            border: 1px solid var(--container-border);
            color: var(--text-color-muted);
            border-radius: var(--border-radius);
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1rem;
            font-family: inherit;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, transform 0.1s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-weight: 500; /* Slightly bolder */
        }
        button:hover, .button-like:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }
        button:active {
             transform: scale(0.97);
        }
        button i, .button-like i {
            font-size: 1em;
            line-height: 1;
        }

        #submit-item-button {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: #fff;
            flex-shrink: 0;
        }
        #submit-item-button:hover {
            background-color: var(--accent-color-darker);
            border-color: var(--accent-color-darker);
            color: #fff; /* Keep white on hover */
        }
         #audio-input-button.recording {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
            color: white;
            animation: pulse 1.5s infinite ease-in-out;
        }
         @keyframes pulse {
            0%, 100% { box-shadow: 0 0 8px 0px rgba(233, 78, 119, 0.5); }
            50% { box-shadow: 0 0 12px 4px rgba(233, 78, 119, 0.7); }
        }

        /* Suggestions Dropdown */
        #suggestions-list {
            list-style-type: none;
            margin: 0; /* Reset margin */
            max-height: 180px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid var(--container-border);
            border-top: none;
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            position: absolute;
            top: 100%; /* Position below the input */
            left: 0;
            width: calc(100% - 180px); /* Adjust based on button/qty width - needs fine-tuning */
            z-index: 100; /* High z-index */
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
            padding: 5px 0;
            opacity: 0; /* Start hidden */
            visibility: hidden;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
        }
        #suggestions-list:not(.hidden) { /* Show when not hidden */
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        #suggestions-list li {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 0.95rem;
        }
        #suggestions-list li:hover {
            background-color: var(--accent-color-darker);
            color: white;
        }


        /* Controls: Sorting and Filtering */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            padding: 15px;
            background: var(--bg-color); /* Slight contrast */
            border-radius: var(--border-radius);
            border: 1px solid var(--container-border);
        }
        .controls label {
            margin-right: 8px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .controls select {
            padding: 8px 12px;
            font-size: 0.9rem;
            min-width: 150px;
        }

        /* List Sections */
        .list-section {
            margin-top: 20px;
        }
        .list-section h2 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--container-border);
        }

        /* Grocery List Styling */
        .item-list {
            list-style: none;
            padding: 0;
        }

        .item-list li {
            background: #fff;
            border: 1px solid var(--container-border);
            border-radius: var(--border-radius);
            margin-bottom: 12px;
            padding: 12px 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            cursor: grab;
            transition: background-color 0.3s ease, opacity 0.3s ease, box-shadow 0.2s ease;
            /* Animation Setup */
            opacity: 1;
            max-height: 100px; /* Adjust as needed */
            overflow: hidden;
        }
        /* Add/Remove Animation */
        .item-list li.item-enter {
            opacity: 0;
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: 0;
            border-width: 0;
        }
         .item-list li.item-exit {
            opacity: 0;
            max-height: 0 !important; /* Force height collapse */
            padding-top: 0 !important;
            padding-bottom: 0 !important;
             margin-bottom: 0 !important;
             border-width: 0 !important;
             transform: translateX(-20px);
             transition: opacity 0.25s ease-out, max-height 0.3s ease-out, transform 0.25s ease-out, padding 0.3s ease-out, margin 0.3s ease-out, border 0.3s ease-out;
        }


        .item-list li:hover {
            border-color: #c0c4c7;
             box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .item-list li.dragging {
            opacity: 0.6;
            background: #eef2f5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: grabbing;
        }
        .item-list li.drag-over {
            border-bottom: 3px solid var(--accent-color);
        }

        .item-checkbox {
            appearance: none;
            width: 22px;
            height: 22px;
            border: 2px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .item-checkbox:hover {
             border-color: var(--accent-color);
        }
        .item-checkbox:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        .item-checkbox:checked::after {
            content: '\f00c';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            font-size: 12px;
            color: #fff;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .item-details {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .item-text {
            font-size: 1rem;
            font-weight: 500; /* Slightly bolder text */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: opacity 0.3s ease;
        }
        .item-quantity-display {
            font-size: 0.85rem;
            color: var(--text-color-muted);
            margin-top: 3px;
        }
        .item-quantity-display:empty { /* Hide if empty */
            display: none;
        }

        /* Editing State */
         .item-details input[type="text"] {
            width: 100%;
            margin-bottom: 5px;
            padding: 8px 10px; /* Slightly smaller padding for edit */
         }

        /* Done List Styling */
        #done-list li {
            background-color: var(--done-color-bg);
            border-color: #c8e6c9; /* Lighter green border */
        }
        #done-list li .item-text,
        #done-list li .item-quantity-display {
            text-decoration: line-through;
            color: var(--done-text-color);
            opacity: 0.8;
        }
        #done-list li .item-checkbox:checked {
             background-color: #66bb6a; /* Green check */
             border-color: #66bb6a;
        }

        .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        .item-actions button {
            padding: 6px 9px;
            font-size: 0.9rem;
            background: transparent;
            border: none;
            color: var(--text-color-muted);
        }
         .item-actions button:hover {
             background: #eee;
             color: var(--text-color);
         }
         .item-actions .remove-button { color: var(--danger-color); }
         .item-actions .remove-button:hover { color: white; background-color: var(--danger-color); }
         .item-actions .edit-button { color: var(--accent-color); }
         .item-actions .edit-button:hover { color: white; background-color: var(--accent-color); }
         /* Save/Cancel buttons */
         .item-actions .save-button { color: #4caf50; } /* Green save */
         .item-actions .save-button:hover { color: white; background-color: #4caf50; }
         .item-actions .cancel-button { color: var(--text-color-muted); }
         .item-actions .cancel-button:hover { color: white; background-color: #999; }


        /* Settings Area */
        #settings-toggle {
            align-self: center;
            margin-top: 10px;
            background-color: var(--bg-color);
        }
         #settings-toggle:hover {
            background-color: #eef2f5;
         }
        #settings {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out, margin-top 0.4s ease-out;
            background: #fff;
            border: 1px solid var(--container-border);
            border-radius: var(--border-radius);
            padding: 0 25px;
            margin-top: 0;
             box-shadow: 0 3px 8px rgba(0,0,0,0.04);
        }
        #settings.open {
             max-height: 600px; /* Generous height */
             padding: 25px;
             margin-top: 15px;
        }
        .settings-content {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
         .settings-row label:first-child { /* Label for select */
             min-width: 90px;
             font-weight: 500;
         }
         .settings-content button, .settings-content label.button-like {
             width: 100%;
             justify-content: center;
             padding: 12px 15px; /* Slightly larger buttons */
         }
         .settings-content button.danger-button,
         .settings-content button[data-key="clearHistory"] /* Target specific button */
         {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
            color: white;
         }
         .settings-content button.danger-button:hover,
         .settings-content button[data-key="clearHistory"]:hover
          {
            background-color: var(--danger-color-darker);
            border-color: var(--danger-color-darker);
         }

         /* Style label like a button */
         .button-like {
            display: inline-block;
            text-align: center;
            background: #fff;
            border: 1px solid var(--container-border);
            color: var(--text-color-muted);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
         }
         .button-like:hover {
             border-color: var(--accent-color);
             color: var(--accent-color);
         }
        input[type="file"] { display: none; }


        /* Empty List Message */
        .empty-list-message {
            text-align: center;
            color: var(--text-color-muted);
            padding: 35px 20px;
            font-style: italic;
            display: none; /* Hidden by default */
            border: 1px dashed var(--container-border);
            border-radius: var(--border-radius);
            margin-top: 10px;
        }
        .empty-list-message.visible {
            display: block;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9rem;
            color: var(--text-color-muted);
            opacity: 0.9;
        }
        footer a {
            color: var(--accent-color);
            text-decoration: none;
            margin: 0 5px;
            transition: color 0.2s ease;
        }
        footer a:hover {
            color: var(--accent-color-darker);
        }
         footer .fab { /* Font awesome brands */
            font-size: 1.3rem; /* Slightly larger social icons */
            vertical-align: middle;
         }


        /* Responsive Adjustments */
        @media (max-width: 650px) {
            body { padding: 10px; }
            #smart-list-app { padding: 20px 15px; gap: 20px;}
            h1 { font-size: 1.6rem; }
            #add-item-form { flex-direction: column; }
            #add-item-form input[type="text"], #item-quantity { width: 100%; }
            #suggestions-list { width: 100%; }
            .controls { flex-direction: column; align-items: stretch; gap: 10px; padding: 12px; }
            .controls div { display: flex; justify-content: space-between; width: 100%; }
            .controls select { min-width: 0; flex-grow: 1; } /* Allow select to grow */
            .item-list li { gap: 10px; padding: 10px 12px; }
            .item-checkbox { width: 20px; height: 20px; }
            .item-text { font-size: 0.95rem; }
            .item-quantity-display { font-size: 0.8rem; }
            .item-actions { gap: 5px; }
            .item-actions button { padding: 5px 7px; font-size: 0.85rem; }
             .settings-row label:first-child { min-width: 70px; }
            footer { font-size: 0.8rem; }
        }

    </style>
</head>
<body>
    <div id="smart-list-app">
        <h1 data-translate-key="title"><i class="fas fa-list-check"></i> Smart List</h1>

        <!-- Add Item Form -->
        <form id="add-item-form">
            <input type="text" id="add-item-input" data-translate-key="addItemPlaceholder" placeholder="Enter item" autocomplete="off" required>
             <!-- Suggestions will appear below this input -->
            <ul id="suggestions-list" class="hidden"></ul>
            <input type="text" id="item-quantity" data-translate-key="quantityPlaceholder" placeholder="Qty (optional)">
            <button id="audio-input-button" type="button" data-translate-key="recordButton" title="Record Item Name"><i class="fas fa-microphone"></i></button>
            <button type="submit" id="submit-item-button" data-translate-key="addButton" title="Add Item"><i class="fas fa-plus"></i> Add</button>
        </form>

        <!-- Controls: Sorting and Filtering -->
        <div class="controls">
             <div>
                <label for="sort-by" data-translate-key="sortByLabel">Sort by:</label>
                <select id="sort-by">
                    <option value="default" data-translate-key="sortDefault">Default</option>
                    <option value="alpha-asc" data-translate-key="sortAlphaAsc">Name (A-Z)</option>
                    <option value="alpha-desc" data-translate-key="sortAlphaDesc">Name (Z-A)</option>
                    <option value="freq-desc" data-translate-key="sortFreqDesc">Frequency (Most)</option>
                    <option value="freq-asc" data-translate-key="sortFreqAsc">Frequency (Least)</option>
                    <option value="date-desc" data-translate-key="sortDateDesc">Last Added (Newest)</option>
                    <option value="date-asc" data-translate-key="sortDateAsc">Last Added (Oldest)</option>
                </select>
            </div>
             <div>
                <label for="filter-by" data-translate-key="filterByLabel">Show:</label>
                <select id="filter-by">
                    <option value="all" data-translate-key="filterAll">All Items</option>
                    <option value="active" data-translate-key="filterActive">Active Only</option>
                    <option value="done" data-translate-key="filterDone">Completed Only</option>
                </select>
            </div>
        </div>

        <!-- Active Items List -->
        <div class="list-section">
            <h2 data-translate-key="activeItemsHeader">Active Items</h2>
            <ul id="active-list" class="item-list">
                <!-- Active items will be rendered here -->
            </ul>
            <p id="empty-active-list-message" class="empty-list-message" data-translate-key="emptyActiveList">No active items. Add some!</p>
        </div>

        <!-- Done Items List -->
        <div class="list-section">
            <h2 data-translate-key="doneItemsHeader">Completed Items</h2>
            <ul id="done-list" class="item-list">
                 <!-- Done items will be rendered here -->
            </ul>
             <p id="empty-done-list-message" class="empty-list-message" data-translate-key="emptyDoneList">No completed items yet.</p>
        </div>


        <!-- Settings Toggle -->
        <button id="settings-toggle" data-key="settingsToggle"><i class="fas fa-cog"></i> <span data-translate-key="settingsShow">Show Settings</span></button>

        <!-- Settings Area -->
        <div id="settings">
             <div class="settings-content">
                 <div class="settings-row">
                     <label for="ui_language" data-translate-key="languageLabel">Language:</label>
                     <select id="ui_language">
                         <option value="en">English</option>
                         <option value="fr">Français</option>
                     </select>
                 </div>
                 <div class="settings-row">
                     <label for="audio_input_language" data-translate-key="speechLanguageLabel">Speech:</label>
                     <select id="audio_input_language">
                         <option value="en-US">English (US)</option>
                         <option value="fr-FR">Français (France)</option>
                         <option value="en-GB">English (UK)</option>
                         <option value="es-ES">Español (España)</option>
                         <!-- Add other languages as needed -->
                     </select>
                 </div>
                 <button id="generate-typical-list" data-key="generateTypical"><i class="fas fa-magic"></i> <span data-translate-key="generateTypical">Generate Typical List</span></button>
                <label class="button-like" for="import-items" data-key="importLabel"><i class="fas fa-upload"></i> <span data-translate-key="importLabel">Import List (.json)</span></label>
                <input type="file" id="import-items" accept=".json">
                <button id="export-items" data-key="exportButton"><i class="fas fa-download"></i> <span data-translate-key="exportButton">Export List (.json)</span></button>
                <button id="clear-list" class="danger-button" data-key="clearList"><i class="fas fa-trash-alt"></i> <span data-translate-key="clearList">Clear Current List</span></button>
                <button id="clear-history" class="danger-button" data-key="clearHistory"><i class="fas fa-history"></i> <span data-translate-key="clearHistory">Clear Purchase History</span></button>
             </div>
        </div>

        <!-- Footer -->
        <footer>
            <span data-translate-key="footerText">Built with</span> <i class="fas fa-heart" style="color: #e06c75;"></i> & AI |
            <!-- Add your social links here if desired -->
            <a href="#" target="_blank" title="Share on Twitter"><i class="fab fa-twitter"></i></a>
            <a href="#" target="_blank" title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a>
            <a href="#" target="_blank" title="Share on Facebook"><i class="fab fa-facebook"></i></a>
        </footer>
    </div>

    <script>
        // --- Translations ---
        const translations = {
            en: {
                title: "Smart List",
                addItemPlaceholder: "Enter item",
                quantityPlaceholder: "Qty (optional)",
                recordButton: "Record Item Name",
                addButton: "Add",
                sortByLabel: "Sort by:",
                sortDefault: "Default",
                sortAlphaAsc: "Name (A-Z)",
                sortAlphaDesc: "Name (Z-A)",
                sortFreqDesc: "Frequency (Most)",
                sortFreqAsc: "Frequency (Least)",
                sortDateDesc: "Last Added (Newest)",
                sortDateAsc: "Last Added (Oldest)",
                filterByLabel: "Show:",
                filterAll: "All Items",
                filterActive: "Active Only",
                filterDone: "Completed Only",
                activeItemsHeader: "Active Items",
                doneItemsHeader: "Completed Items",
                emptyActiveList: "No active items. Add some!",
                emptyDoneList: "No completed items yet.",
                settingsShow: "Show Settings",
                settingsHide: "Hide Settings",
                languageLabel: "Language:",
                speechLanguageLabel: "Speech:",
                generateTypical: "Generate Typical List",
                importLabel: "Import List (.json)",
                exportButton: "Export List (.json)",
                clearList: "Clear Current List",
                clearHistory: "Clear Purchase History",
                footerText: "Built with",
                alertRemoveItem: "Are you sure you want to remove \"{itemName}\"?",
                alertClearList: "Are you sure you want to clear all items from the current list?",
                alertClearHistory: "WARNING: This will permanently delete all history and suggestions data. Are you sure?",
                alertItemExists: "\"{itemName}\" is already on the active list.",
                alertNoHistory: "Not enough history to generate a typical list. Keep using the app!",
                alertItemsAdded: "Added {count} typical items to your list.",
                alertItemsExist: "Your current list already contains most of your typical items.",
                alertExportSuccess: "Data exported successfully!",
                alertExportFailed: "Failed to export data.",
                alertImportConfirm: "This will replace your current list and history. Are you sure?",
                alertImportSuccess: "Data imported successfully!",
                alertImportFailed: "Failed to import data: {error}",
                alertReadFileFailed: "Failed to read the file.",
                alertListEmpty: "List is already empty.",
                alertHistoryEmpty: "History is already empty.",
                alertNoInput: "Please enter an item name.",
                alertSpeechError: "Speech recognition error: {error}",
                alertSpeechNotSupported: "Sorry, your browser doesn't support Speech Recognition.",
                editButtonTitle: "Edit Item",
                saveButtonTitle: "Save Changes",
                cancelButtonTitle: "Cancel Edit",
                removeButtonTitle: "Remove Item",
            },
            fr: {
                title: "Liste Intelligente",
                addItemPlaceholder: "Entrer un article",
                quantityPlaceholder: "Qté (optionnel)",
                recordButton: "Enregistrer l'article",
                addButton: "Ajouter",
                sortByLabel: "Trier par :",
                sortDefault: "Défaut",
                sortAlphaAsc: "Nom (A-Z)",
                sortAlphaDesc: "Nom (Z-A)",
                sortFreqDesc: "Fréquence (Max)",
                sortFreqAsc: "Fréquence (Min)",
                sortDateDesc: "Ajout (Récent)",
                sortDateAsc: "Ajout (Ancien)",
                filterByLabel: "Afficher :",
                filterAll: "Tous les articles",
                filterActive: "Actifs seulement",
                filterDone: "Terminés seulement",
                activeItemsHeader: "Articles Actifs",
                doneItemsHeader: "Articles Terminés",
                emptyActiveList: "Aucun article actif. Ajoutez-en !",
                emptyDoneList: "Aucun article terminé pour le moment.",
                settingsShow: "Afficher Paramètres",
                settingsHide: "Masquer Paramètres",
                languageLabel: "Langue :",
                speechLanguageLabel: "Voix :",
                generateTypical: "Générer Liste Type",
                importLabel: "Importer Liste (.json)",
                exportButton: "Exporter Liste (.json)",
                clearList: "Vider la Liste Actuelle",
                clearHistory: "Effacer l'Historique",
                footerText: "Créé avec",
                alertRemoveItem: "Êtes-vous sûr de vouloir supprimer \"{itemName}\" ?",
                alertClearList: "Êtes-vous sûr de vouloir vider la liste actuelle ?",
                alertClearHistory: "ATTENTION : Ceci supprimera définitivement tout l'historique et les suggestions. Êtes-vous sûr ?",
                alertItemExists: "\"{itemName}\" est déjà dans la liste active.",
                alertNoHistory: "Pas assez d'historique pour générer une liste type. Continuez à utiliser l'app !",
                alertItemsAdded: "{count} articles types ajoutés à votre liste.",
                alertItemsExist: "Votre liste actuelle contient déjà la plupart de vos articles types.",
                alertExportSuccess: "Données exportées avec succès !",
                alertExportFailed: "Échec de l'exportation des données.",
                alertImportConfirm: "Ceci remplacera votre liste et historique actuels. Êtes-vous sûr ?",
                alertImportSuccess: "Données importées avec succès !",
                alertImportFailed: "Échec de l'importation : {error}",
                alertReadFileFailed: "Échec de la lecture du fichier.",
                alertListEmpty: "La liste est déjà vide.",
                alertHistoryEmpty: "L'historique est déjà vide.",
                alertNoInput: "Veuillez entrer un nom d'article.",
                alertSpeechError: "Erreur de reconnaissance vocale : {error}",
                alertSpeechNotSupported: "Désolé, votre navigateur ne supporte pas la reconnaissance vocale.",
                editButtonTitle: "Modifier l'article",
                saveButtonTitle: "Enregistrer",
                cancelButtonTitle: "Annuler",
                removeButtonTitle: "Supprimer l'article",
            }
        };

        // --- DOM Elements ---
        const smartListApp = document.getElementById('smart-list-app');
        const addItemForm = document.getElementById('add-item-form');
        const itemInput = document.getElementById('add-item-input');
        const quantityInput = document.getElementById('item-quantity');
        const suggestionsList = document.getElementById('suggestions-list');
        const audioButton = document.getElementById('audio-input-button');
        const audioLangSelect = document.getElementById('audio_input_language');
        const activeList = document.getElementById('active-list');
        const doneList = document.getElementById('done-list');
        const emptyActiveListMessage = document.getElementById('empty-active-list-message');
        const emptyDoneListMessage = document.getElementById('empty-done-list-message');
        const sortSelect = document.getElementById('sort-by');
        const filterSelect = document.getElementById('filter-by');
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsDiv = document.getElementById('settings');
        const uiLangSelect = document.getElementById('ui_language');
        const generateTypicalButton = document.getElementById('generate-typical-list');
        const importInput = document.getElementById('import-items');
        const exportButton = document.getElementById('export-items');
        const clearListButton = document.getElementById('clear-list');
        const clearHistoryButton = document.getElementById('clear-history');

        // --- State ---
        let currentItems = [];
        let itemPurchaseHistory = {};
        let isSpeechRecognitionActive = false;
        let draggedItem = null;
        let currentLanguage = 'en'; // Default language

        // --- Speech Recognition Setup (Same as before, but using localized alerts) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
         if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                isSpeechRecognitionActive = true;
                audioButton.classList.add('recording');
                // Title is set by setLanguage now
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                itemInput.value = transcript;
                itemInput.focus();
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                alert(getTranslation('alertSpeechError').replace('{error}', event.error));
            };

            recognition.onend = () => {
                isSpeechRecognitionActive = false;
                audioButton.classList.remove('recording');
                 // Title is set by setLanguage now
            };

            audioButton.addEventListener('click', () => {
                if (!SpeechRecognition) {
                    alert(getTranslation('alertSpeechNotSupported'));
                    return;
                }
                if (isSpeechRecognitionActive) {
                    recognition.stop();
                } else {
                    try {
                        recognition.lang = audioLangSelect.value;
                        recognition.start();
                    } catch (e) {
                         console.error("Could not start recognition:", e);
                         isSpeechRecognitionActive = false;
                         audioButton.classList.remove('recording');
                    }
                }
            });
        } else {
            audioButton.disabled = true;
            // Title is set by setLanguage now
            console.warn("Speech Recognition API not supported.");
        }


        // --- Localization Functions ---
        const getTranslation = (key, replacements = {}) => {
            let text = translations[currentLanguage]?.[key] || translations.en[key] || `Missing key: ${key}`;
             for (const placeholder in replacements) {
                text = text.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            return text;
        };

        const setLanguage = (lang) => {
            currentLanguage = lang;
            localStorage.setItem('smartListLanguage', lang);
            uiLangSelect.value = lang; // Update the dropdown

            document.querySelectorAll('[data-translate-key]').forEach(element => {
                const key = element.dataset.translateKey;
                const translation = getTranslation(key);

                if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                    if (element.placeholder) {
                        element.placeholder = translation;
                    }
                } else if (element.tagName === 'BUTTON' || element.tagName === 'OPTION') {
                    // Handle buttons/options possibly having icons or child spans
                     const textNode = Array.from(element.childNodes).find(node => node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '');
                     const spanNode = element.querySelector('span'); // Check for specific span to update
                    if (spanNode && element.dataset.key === element.id) { // Target specific spans within buttons if needed
                       spanNode.textContent = translation;
                     } else if (textNode) {
                        textNode.textContent = ` ${translation} `; // Add space around text maybe
                     } else if (element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE) {
                         element.textContent = translation; // Simple case
                     } else if (spanNode) {
                        spanNode.textContent = translation; // Fallback to first span
                     } else {
                          // Attempt to set text content directly if no specific node found
                          // Be careful not to overwrite icons
                          let icon = element.querySelector('i');
                          element.textContent = translation;
                          if(icon) element.prepend(icon, ' '); // Re-add icon if overwritten
                     }
                } else {
                    element.textContent = translation; // For h1, h2, p, label, etc.
                }

                 // Update titles for accessibility/tooltips
                 if (element.title || element.dataset.key) { // Use data-key if title needs translation
                     const titleKey = element.dataset.translateKey.replace(/Label$|Placeholder$|Header$|Show$|Hide$|Text$/, 'ButtonTitle') // Try to infer title key
                                     || element.dataset.key + 'Title'
                                     || key; // Fallback
                     const titleTranslation = getTranslation(titleKey);
                     if (!titleTranslation.startsWith('Missing key:')) {
                         element.title = titleTranslation;
                     } else if (key.match(/Button$/) || key.match(/Label$/)){
                         element.title = translation; // Use main translation as title for buttons/labels if specific title missing
                     }
                 }
            });

            // Special cases for button text that changes
            const settingsOpen = settingsDiv.classList.contains('open');
            settingsToggle.querySelector('span').textContent = getTranslation(settingsOpen ? 'settingsHide' : 'settingsShow');

             // Update aria-labels etc. if needed

             renderItems(); // Re-render to update any dynamic text in list items if necessary (e.g., future features)
        };


        // --- Utility Functions ---
        const generateId = () => `item-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        const sanitizeText = (text) => text ? text.trim() : ''; // Handle potential null/undefined

        // --- Local Storage Functions ---
        const saveState = () => {
            try {
                localStorage.setItem('smartListItems', JSON.stringify(currentItems));
                localStorage.setItem('smartListItemHistory', JSON.stringify(itemPurchaseHistory));
                // Language is saved in setLanguage
            } catch (e) {
                console.error("Error saving state:", e);
            }
        };

        const loadState = () => {
            try {
                const storedItems = localStorage.getItem('smartListItems');
                const storedHistory = localStorage.getItem('smartListItemHistory');
                currentItems = storedItems ? JSON.parse(storedItems) : [];
                itemPurchaseHistory = storedHistory ? JSON.parse(storedHistory) : {};
                currentLanguage = localStorage.getItem('smartListLanguage') || 'en';

                 // Ensure items have the isEditing flag (for backwards compatibility)
                 currentItems = currentItems.map(item => ({ ...item, isEditing: item.isEditing || false }));

            } catch (e) {
                console.error("Error loading state:", e);
                currentItems = [];
                itemPurchaseHistory = {};
                currentLanguage = 'en';
            }
        };

        // --- History Management (Same as before) ---
        const updateHistory = (itemText, isPurchase) => {
             const text = sanitizeText(itemText).toLowerCase();
             if (!text) return;
             if (!itemPurchaseHistory[text]) {
                 itemPurchaseHistory[text] = { count: 0, lastPurchased: null, addedDate: new Date().toISOString() }; // Track added date
             }
              if (isPurchase) { // Only increment/update date on purchase (marking done)
                  itemPurchaseHistory[text].count = (itemPurchaseHistory[text].count || 0) + 1;
                  itemPurchaseHistory[text].lastPurchased = new Date().toISOString();
             } else if(!itemPurchaseHistory[text].addedDate) {
                 // If adding an item that somehow lost its addedDate
                 itemPurchaseHistory[text].addedDate = new Date().toISOString();
             }
        };


        // --- Rendering Functions ---
        const renderItems = () => {
            // Clear previous items
            activeList.innerHTML = '';
            doneList.innerHTML = '';

             // 1. Filter (decide which items to consider based on filter control)
             let itemsToConsider = currentItems;
             const filterValue = filterSelect.value;
             if (filterValue === 'active') {
                 itemsToConsider = currentItems.filter(item => !item.done);
             } else if (filterValue === 'done') {
                 itemsToConsider = currentItems.filter(item => item.done);
             }

             // 2. Sort the *considered* items
             const sortedItems = sortItems(itemsToConsider);

             // 3. Separate into active and done *based on their actual state*
             const activeItems = sortedItems.filter(item => !item.done);
             const doneItems = sortedItems.filter(item => item.done);

             // 4. Render into respective lists (only if filter allows)
             let activeRendered = false;
             if (filterValue === 'all' || filterValue === 'active') {
                 if (activeItems.length > 0) {
                     activeItems.forEach(item => {
                        const el = createItemElement(item);
                        // Add animation class - will be removed after transition
                        el.classList.add('item-enter');
                        activeList.appendChild(el);
                        // Trigger reflow before removing class for transition
                        void el.offsetWidth;
                        el.classList.remove('item-enter');

                     });
                     emptyActiveListMessage.classList.remove('visible');
                     activeRendered = true;
                 } else {
                     emptyActiveListMessage.classList.add('visible');
                 }
             } else {
                 emptyActiveListMessage.classList.remove('visible'); // Hide if not showing active
             }


            let doneRendered = false;
             if (filterValue === 'all' || filterValue === 'done') {
                 if (doneItems.length > 0) {
                     doneItems.forEach(item => {
                        const el = createItemElement(item);
                        // Add animation class
                        el.classList.add('item-enter');
                        doneList.appendChild(el);
                         // Trigger reflow
                        void el.offsetWidth;
                        el.classList.remove('item-enter');
                     });
                     emptyDoneListMessage.classList.remove('visible');
                     doneRendered = true;
                 } else {
                     emptyDoneListMessage.classList.add('visible');
                 }
             } else {
                 emptyDoneListMessage.classList.remove('visible'); // Hide if not showing done
             }

              // Hide list headers if the filter hides the list and it's empty
             activeList.previousElementSibling.style.display = (filterValue === 'done' && !activeRendered) ? 'none' : 'block';
             doneList.previousElementSibling.style.display = (filterValue === 'active' && !doneRendered) ? 'none' : 'block';


            updateDragAndDropListeners(); // Re-attach listeners
            saveState(); // Save state after render
        };

         const sortItems = (items) => {
             const sortValue = sortSelect.value;
             const sortedItems = [...items]; // Create a copy

             const getItemHistory = (itemText) => itemPurchaseHistory[sanitizeText(itemText).toLowerCase()] || { count: 0, lastPurchased: null, addedDate: null };

             sortedItems.sort((a, b) => {
                 const historyA = getItemHistory(a.text);
                 const historyB = getItemHistory(b.text);
                 const textA = sanitizeText(a.text).toLowerCase();
                 const textB = sanitizeText(b.text).toLowerCase();

                 // Primary sort: keep done items separate if filtering 'all' - handled by render logic now
                 // Secondary sort based on selection:
                 switch (sortValue) {
                    case 'alpha-asc': return textA.localeCompare(textB);
                    case 'alpha-desc': return textB.localeCompare(textA);
                    case 'freq-desc': return (historyB.count || 0) - (historyA.count || 0);
                    case 'freq-asc': return (historyA.count || 0) - (historyB.count || 0);
                     case 'date-desc': // Sort by Added Date (Newest First)
                         const dateA_add = historyA.addedDate ? new Date(historyA.addedDate) : new Date(0); // Fallback for old data
                         const dateB_add = historyB.addedDate ? new Date(historyB.addedDate) : new Date(0);
                         return dateB_add - dateA_add;
                     case 'date-asc': // Sort by Added Date (Oldest First)
                         const dateA_add_asc = historyA.addedDate ? new Date(historyA.addedDate) : new Date(0);
                         const dateB_add_asc = historyB.addedDate ? new Date(historyB.addedDate) : new Date(0);
                         return dateA_add_asc - dateB_add_asc;
                     case 'default': // Use creation timestamp from ID
                     default:
                        try {
                           const idTimeA = parseInt(a.id.split('-')[1] || 0);
                           const idTimeB = parseInt(b.id.split('-')[1] || 0);
                           return idTimeA - idTimeB; // Oldest first by default (original add order)
                        } catch (e) { return 0; } // Fallback if ID format changes
                 }
             });
             return sortedItems;
        };

        const createItemElement = (item) => {
            const li = document.createElement('li');
            li.dataset.id = item.id;
            li.draggable = true;
            // No 'done' class needed here, it's determined by which list it's in

            // Checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = item.done;
            checkbox.classList.add('item-checkbox');
            checkbox.addEventListener('change', () => toggleDone(item.id));
            li.appendChild(checkbox);

            // Item Details or Edit Inputs
            const detailsDiv = document.createElement('div');
            detailsDiv.classList.add('item-details');
            li.appendChild(detailsDiv);

            if (item.isEditing) {
                 const textInput = document.createElement('input');
                 textInput.type = 'text';
                 textInput.value = item.text;
                 textInput.classList.add('edit-item-text');
                 detailsDiv.appendChild(textInput);

                 const quantInput = document.createElement('input');
                 quantInput.type = 'text';
                 quantInput.value = item.quantity || ''; // Ensure value is not null/undefined
                 quantInput.placeholder = getTranslation('quantityPlaceholder'); // Use translated placeholder
                 quantInput.classList.add('edit-item-quantity');
                 detailsDiv.appendChild(quantInput);

                 setTimeout(() => textInput.focus(), 0);
            } else {
                const textSpan = document.createElement('span');
                textSpan.textContent = item.text;
                textSpan.classList.add('item-text');
                detailsDiv.appendChild(textSpan);

                // Only show quantity span if quantity has value
                if (item.quantity && item.quantity.trim() !== '') {
                    const quantSpan = document.createElement('span');
                    quantSpan.textContent = item.quantity;
                    quantSpan.classList.add('item-quantity-display');
                    detailsDiv.appendChild(quantSpan);
                }
            }

            // Action Buttons
            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('item-actions');
            li.appendChild(actionsDiv);

            if (item.isEditing) {
                 const saveButton = document.createElement('button');
                 saveButton.innerHTML = '<i class="fas fa-save"></i>';
                 saveButton.title = getTranslation('saveButtonTitle');
                 saveButton.classList.add('save-button');
                 saveButton.addEventListener('click', (e) => {
                     e.stopPropagation();
                     const newText = li.querySelector('.edit-item-text').value;
                     const newQuantity = li.querySelector('.edit-item-quantity').value;
                     saveEdit(item.id, newText, newQuantity);
                 });
                 actionsDiv.appendChild(saveButton);

                 const cancelButton = document.createElement('button');
                 cancelButton.innerHTML = '<i class="fas fa-times"></i>';
                 cancelButton.title = getTranslation('cancelButtonTitle');
                 cancelButton.classList.add('cancel-button');
                 cancelButton.addEventListener('click', (e) => {
                     e.stopPropagation();
                     cancelEdit(item.id);
                 });
                 actionsDiv.appendChild(cancelButton);

                 li.querySelectorAll('input[type="text"]').forEach(input => {
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') saveButton.click();
                        else if (e.key === 'Escape') cancelButton.click();
                    });
                 });
            } else {
                const editButton = document.createElement('button');
                editButton.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                editButton.title = getTranslation('editButtonTitle');
                editButton.classList.add('edit-button');
                editButton.addEventListener('click', (e) => {
                    e.stopPropagation(); startEdit(item.id);
                });
                actionsDiv.appendChild(editButton);

                const removeButton = document.createElement('button');
                removeButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
                removeButton.title = getTranslation('removeButtonTitle');
                removeButton.classList.add('remove-button');
                removeButton.addEventListener('click', (e) => {
                    e.stopPropagation(); removeItemWithAnimation(item.id, li); // Pass element for animation
                });
                actionsDiv.appendChild(removeButton);
            }

            return li;
        };

        // --- Item CRUD Functions ---
        const addItem = (text, quantity) => {
            const cleanText = sanitizeText(text);
            if (!cleanText) {
                alert(getTranslation('alertNoInput'));
                return;
            }

             const exists = currentItems.some(item => sanitizeText(item.text).toLowerCase() === cleanText.toLowerCase() && !item.done);
             if (exists) {
                 alert(getTranslation('alertItemExists', { itemName: cleanText }));
                 return;
             }

            const newItem = {
                id: generateId(),
                text: cleanText,
                quantity: sanitizeText(quantity), // Quantity is optional
                done: false,
                isEditing: false
            };
            currentItems.unshift(newItem);
            updateHistory(cleanText, false); // Add/update history, mark addedDate
            renderItems(); // Render will handle placing it in the active list with animation
        };

         // Separate function to handle animation before removing data
         const removeItemWithAnimation = (id, element) => {
             const item = currentItems.find(item => item.id === id);
             if (!item) return;

             if (!confirm(getTranslation('alertRemoveItem', { itemName: item.text }))) {
                 return;
             }

             element.classList.add('item-exit'); // Add exit animation class

             // Wait for animation to finish before removing from data and state
             element.addEventListener('transitionend', () => {
                 const itemIndex = currentItems.findIndex(item => item.id === id);
                 if (itemIndex > -1) {
                     currentItems.splice(itemIndex, 1);
                     saveState(); // Save state *after* removal confirmed by animation end
                     // No need to re-render the whole list here, element is gone
                      // But we need to update empty messages if necessary
                      checkEmptyMessages();
                 }
             }, { once: true }); // Ensure listener runs only once
         };

         const checkEmptyMessages = () => {
            emptyActiveListMessage.classList.toggle('visible', activeList.children.length === 0);
            emptyDoneListMessage.classList.toggle('visible', doneList.children.length === 0);
             // Also hide/show headers based on filter + emptiness
             const filterValue = filterSelect.value;
             activeList.previousElementSibling.style.display = (filterValue === 'done' && activeList.children.length === 0) ? 'none' : 'block';
             doneList.previousElementSibling.style.display = (filterValue === 'active' && doneList.children.length === 0) ? 'none' : 'block';
         };


        const toggleDone = (id) => {
            const itemIndex = currentItems.findIndex(item => item.id === id);
            if (itemIndex > -1) {
                const item = currentItems[itemIndex];
                const wasDone = item.done;
                item.done = !item.done;

                // If moving to done, update history as purchased
                if (item.done && !wasDone) {
                     updateHistory(item.text, true);
                }

                // If editing, cancel edit when toggling done state
                 if (item.isEditing) {
                     item.isEditing = false;
                 }

                renderItems(); // Re-render handles moving between lists and applies animations
            }
        };

        const startEdit = (id) => {
            currentItems = currentItems.map(item => ({
                ...item,
                isEditing: item.id === id
            }));
            renderItems();
        };

        const saveEdit = (id, newText, newQuantity) => {
            const cleanText = sanitizeText(newText);
            if (!cleanText) {
                alert(getTranslation('alertNoInput'));
                return;
            }
            currentItems = currentItems.map(item => {
                if (item.id === id) {
                    // If text changed significantly, maybe update history? For simplicity, don't link old/new history.
                    return { ...item, text: cleanText, quantity: sanitizeText(newQuantity), isEditing: false };
                }
                return item;
            });
            renderItems();
        };

        const cancelEdit = (id) => {
             currentItems = currentItems.map(item => item.id === id ? { ...item, isEditing: false } : item);
             renderItems();
        };

        // --- Feature Functions (Suggestions, Typical List, Import/Export - mostly unchanged logic, added localization) ---

         const showSuggestions = (query) => {
             suggestionsList.innerHTML = '';
             if (!query) {
                 suggestionsList.classList.add('hidden');
                 return;
             }
             const lowerQuery = query.toLowerCase();
             // Suggest based on history keys (already lowercase)
             const historyEntries = Object.entries(itemPurchaseHistory);
             const sortedHistory = historyEntries.sort(([, histA], [, histB]) => (histB.count || 0) - (histA.count || 0));

             const matchingSuggestions = sortedHistory
                 .filter(([text]) => text.includes(lowerQuery))
                 .slice(0, 6); // Show 6 suggestions

             if (matchingSuggestions.length > 0) {
                 matchingSuggestions.forEach(([text]) => {
                     const li = document.createElement('li');
                     // Display with capitalization
                     li.textContent = text.charAt(0).toUpperCase() + text.slice(1);
                     li.addEventListener('click', () => {
                         itemInput.value = li.textContent;
                         suggestionsList.classList.add('hidden');
                         suggestionsList.innerHTML = '';
                         quantityInput.focus();
                     });
                     suggestionsList.appendChild(li);
                 });
                 suggestionsList.classList.remove('hidden');
             } else {
                 suggestionsList.classList.add('hidden');
             }
        };

        const generateTypicalList = () => {
            const threshold = 2;
            const maxItems = 15;
             const typicalItems = Object.entries(itemPurchaseHistory)
                .filter(([, hist]) => (hist.count || 0) >= threshold)
                .sort(([, histA], [, histB]) => (histB.count || 0) - (histA.count || 0))
                .slice(0, maxItems)
                .map(([text]) => text);

             if (typicalItems.length === 0) {
                 alert(getTranslation('alertNoHistory'));
                 return;
             }
             let addedCount = 0;
             typicalItems.forEach(text => {
                 const alreadyActive = currentItems.some(item =>
                     !item.done && sanitizeText(item.text).toLowerCase() === text
                 );
                 if (!alreadyActive) {
                     const originalCaseText = Object.keys(itemPurchaseHistory).find(k => k.toLowerCase() === text) || text;
                     addItem(originalCaseText.charAt(0).toUpperCase() + originalCaseText.slice(1), '');
                     addedCount++;
                 }
             });
             if (addedCount > 0) {
                 // alert(getTranslation('alertItemsAdded', { count: addedCount })); // Alert can be annoying, maybe subtle confirmation?
             } else {
                 alert(getTranslation('alertItemsExist'));
             }
             // renderItems(); // addItem already calls render
        };

        const exportData = () => {
            try {
                const dataToExport = {
                    currentList: currentItems.map(({ isEditing, ...item }) => item),
                    purchaseHistory: itemPurchaseHistory
                };
                const dataStr = JSON.stringify(dataToExport, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.download = `smart_list_backup_${new Date().toISOString().slice(0,10)}.json`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                // alert(getTranslation('alertExportSuccess')); // Optional confirmation
            } catch (e) {
                console.error("Export failed:", e);
                alert(getTranslation('alertExportFailed'));
            }
        };

        const importData = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (importedData && typeof importedData === 'object') {
                        const hasList = Array.isArray(importedData.currentList);
                        const hasHistory = typeof importedData.purchaseHistory === 'object';

                        if (!confirm(getTranslation('alertImportConfirm'))) {
                           importInput.value = ''; return;
                        }
                        currentItems = hasList ? importedData.currentList.map(item => ({...item, isEditing: false })) : [];
                        itemPurchaseHistory = hasHistory ? importedData.purchaseHistory : {};
                        renderItems();
                        alert(getTranslation('alertImportSuccess'));
                    } else { throw new Error("Invalid file format."); }
                } catch (error) {
                    console.error("Import failed:", error);
                    alert(getTranslation('alertImportFailed', { error: error.message }));
                } finally { importInput.value = ''; }
            };
            reader.onerror = () => {
                alert(getTranslation('alertReadFileFailed')); importInput.value = '';
            };
            reader.readAsText(file);
        };

        const clearCurrentList = () => {
            if (currentItems.length > 0 && confirm(getTranslation('alertClearList'))) {
                // Animate removal of all items
                 const allItems = [...activeList.children, ...doneList.children];
                 if (allItems.length > 0) {
                     allItems.forEach(el => el.classList.add('item-exit'));
                     allItems[allItems.length - 1].addEventListener('transitionend', () => {
                         currentItems = [];
                         renderItems(); // Clears lists properly and saves state
                     }, { once: true });
                 } else { // If lists somehow empty but data not
                    currentItems = [];
                    renderItems();
                 }
            } else if (currentItems.length === 0) {
                alert(getTranslation('alertListEmpty'));
            }
        };

        const clearHistory = () => {
             if (Object.keys(itemPurchaseHistory).length > 0 && confirm(getTranslation('alertClearHistory'))) {
                itemPurchaseHistory = {};
                renderItems(); // Save the empty history
             } else if (Object.keys(itemPurchaseHistory).length === 0) {
                 alert(getTranslation('alertHistoryEmpty'));
             }
        };

        // --- Drag and Drop (Adjusted for two lists) ---
        let dragOverElement = null;

        function handleDragStart(e) {
            // Prevent dragging from input/button clicks inside list item
            if (e.target.closest('input, button')) {
                e.preventDefault();
                return;
            }
            draggedItem = e.currentTarget; // The LI element
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedItem.dataset.id);
            setTimeout(() => draggedItem.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            if (draggedItem) draggedItem.classList.remove('dragging');
            if (dragOverElement) dragOverElement.classList.remove('drag-over');
            draggedItem = null; dragOverElement = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            const targetList = e.target.closest('.item-list');
            // Allow dropping only within the *same* list type (active or done)
            if (!draggedItem || !targetList || targetList.id !== draggedItem.parentElement.id) {
                e.dataTransfer.dropEffect = 'none';
                if(dragOverElement) dragOverElement.classList.remove('drag-over');
                dragOverElement = null;
                return;
            }
             e.dataTransfer.dropEffect = 'move';
             const target = e.target.closest('li');
             if (target && target !== draggedItem && target !== dragOverElement) {
                  if(dragOverElement) dragOverElement.classList.remove('drag-over');
                  target.classList.add('drag-over');
                  dragOverElement = target;
             }
        }

        function handleDragLeave(e) {
            // Use relatedTarget to check if leaving the list item entirely or moving to a child
             if (!e.currentTarget.contains(e.relatedTarget)) {
                  if(dragOverElement && e.currentTarget === dragOverElement) {
                      dragOverElement.classList.remove('drag-over');
                      dragOverElement = null;
                  }
             }
        }

        function handleDrop(e) {
            e.preventDefault();
             if (dragOverElement && draggedItem && dragOverElement !== draggedItem && dragOverElement.parentElement.id === draggedItem.parentElement.id) {
                 dragOverElement.classList.remove('drag-over');
                 const draggedId = e.dataTransfer.getData('text/plain');
                 const targetId = dragOverElement.dataset.id;

                 const draggedIndex = currentItems.findIndex(item => item.id === draggedId);
                 let targetIndex = currentItems.findIndex(item => item.id === targetId);

                 if (draggedIndex !== -1 && targetIndex !== -1) {
                     const [movedItem] = currentItems.splice(draggedIndex, 1);
                      // Adjust target index after splice if necessary
                     targetIndex = currentItems.findIndex(item => item.id === targetId);
                     // Decide whether to place before or after target based on cursor position relative to target center? Simpler: place before.
                     currentItems.splice(targetIndex, 0, movedItem);
                     renderItems();
                 }
            }
             handleDragEnd(e); // Clean up
        }

        function updateDragAndDropListeners() {
            const items = document.querySelectorAll('.item-list li');
            items.forEach(item => {
                // Remove old listeners first to prevent duplicates if called multiple times
                item.removeEventListener('dragstart', handleDragStart);
                item.removeEventListener('dragend', handleDragEnd);
                item.removeEventListener('dragover', handleDragOver);
                item.removeEventListener('dragleave', handleDragLeave);
                item.removeEventListener('drop', handleDrop);
                // Add new listeners
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
                // Basic Touch handlers (similar logic, simplified)
                 addTouchListeners(item); // Add touch separately
            });
        }

         function addTouchListeners(item) {
             // Simplified touch handling - may need refinement for complex scenarios
             let touchStartY = 0, touchDraggedItem = null, touchDragOverElement = null;

             item.ontouchstart = (e) => {
                  if (e.target.closest('input, button')) return;
                  touchDraggedItem = e.currentTarget;
                  touchStartY = e.touches[0].clientY;
                  touchDraggedItem.style.opacity = '0.6';
                  touchDraggedItem.style.zIndex = '1000';
                   // Prevent scroll only if drag starts
                  // document.body.style.overflow = 'hidden';
             };

             item.ontouchmove = (e) => {
                 if (!touchDraggedItem) return;
                 e.preventDefault(); // Prevent scroll while dragging item
                 const currentTouchY = e.touches[0].clientY;
                 const diffY = currentTouchY - touchStartY;
                 touchDraggedItem.style.transform = `translateY(${diffY}px)`;

                 const elementUnderTouch = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
                 const potentialTarget = elementUnderTouch ? elementUnderTouch.closest('li') : null;
                  // Only allow drop within same list
                  if (potentialTarget && potentialTarget !== touchDraggedItem && potentialTarget.parentElement.id === touchDraggedItem.parentElement.id) {
                     if(touchDragOverElement && touchDragOverElement !== potentialTarget) touchDragOverElement.classList.remove('drag-over');
                     if(potentialTarget !== touchDragOverElement) potentialTarget.classList.add('drag-over');
                     touchDragOverElement = potentialTarget;
                  } else if(touchDragOverElement) {
                      touchDragOverElement.classList.remove('drag-over');
                      touchDragOverElement = null;
                  }
             };

             item.ontouchend = (e) => {
                 if (!touchDraggedItem) return;
                 // document.body.style.overflow = 'auto'; // Restore scroll
                 touchDraggedItem.style.opacity = '1';
                 touchDraggedItem.style.transform = 'translateY(0px)';
                 touchDraggedItem.style.zIndex = 'auto';

                 const finalTarget = touchDragOverElement;
                 if (finalTarget && finalTarget !== touchDraggedItem) {
                     finalTarget.classList.remove('drag-over');
                     const draggedId = touchDraggedItem.dataset.id;
                     const targetId = finalTarget.dataset.id;
                     const draggedIndex = currentItems.findIndex(item => item.id === draggedId);
                     let targetIndex = currentItems.findIndex(item => item.id === targetId);
                     if (draggedIndex !== -1 && targetIndex !== -1) {
                         const [movedItem] = currentItems.splice(draggedIndex, 1);
                         targetIndex = currentItems.findIndex(item => item.id === targetId);
                         currentItems.splice(targetIndex, 0, movedItem);
                         renderItems();
                     }
                 } else if (touchDragOverElement) {
                     touchDragOverElement.classList.remove('drag-over');
                 }
                 touchDraggedItem = null; touchDragOverElement = null;
             };
         }

        // --- Event Listeners ---
        addItemForm.addEventListener('submit', (e) => {
            e.preventDefault();
            addItem(itemInput.value, quantityInput.value);
            itemInput.value = '';
            quantityInput.value = '';
            itemInput.focus();
            suggestionsList.classList.add('hidden');
        });

         itemInput.addEventListener('input', () => showSuggestions(itemInput.value));
         itemInput.addEventListener('focus', () => showSuggestions(itemInput.value)); // Show suggestions on focus too

         document.addEventListener('click', (e) => {
            // Hide suggestions if clicking outside the input or the suggestion list itself
             if (!itemInput.contains(e.target) && !suggestionsList.contains(e.target)) {
                 suggestionsList.classList.add('hidden');
             }
         });


        sortSelect.addEventListener('change', renderItems);
        filterSelect.addEventListener('change', renderItems);

        settingsToggle.addEventListener('click', () => {
            const isOpen = settingsDiv.classList.toggle('open');
            settingsToggle.querySelector('span').textContent = getTranslation(isOpen ? 'settingsHide' : 'settingsShow');
        });

        uiLangSelect.addEventListener('change', (e) => setLanguage(e.target.value));

        generateTypicalButton.addEventListener('click', generateTypicalList);
        exportButton.addEventListener('click', exportData);
        importInput.addEventListener('change', importData);
        clearListButton.addEventListener('click', clearCurrentList);
        clearHistoryButton.addEventListener('click', clearHistory);


        // --- Initialization ---
        loadState();
        setLanguage(currentLanguage); // Apply loaded language
        // Initial render happens within setLanguage now

    </script>
</body>
</html>
